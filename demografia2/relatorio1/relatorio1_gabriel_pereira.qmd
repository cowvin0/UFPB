---
block-headings: false
# cache: true
template-partials:
  - includes/before-body.tex
toc-title: \centering Sumário \thispagestyle{empty}
format:
  pdf:
    pdf-engine: lualatex
    papersize: A4
    keep-tex: true
    geometry:
      - left=3cm,
      - right=2cm,
      - top=3cm,
      - bottom=2cm
    code-block-bg: "#F0F2F4"
    code-block-background: true
number-sections: true
indent: true
documentclass: scrreprt
whitespace: small
lang: pt-br
bibliography: includes/bib.bib
csl: includes/ufpe-abnt.csl
toc: true
title: Primeiro relatório da disciplina de demografia II - Roraima
author: Gabriel de Jesus Pereira
date: today
date-format: "MMMM, YYYY"
highlight-style: github
fontsize: 12pt
interlinespace: 1.5pt
fig-cap-location: bottom
warning: false
echo: false
include-in-header:
  - includes/pdf_config.sty
---


\pagenumbering{arabic}
\pagestyle{fancy}

\fancyhf{}
\fancyhead[RO, LE]{\thepage}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{\thepage}

\fancypagestyle{plain}{
  \pagestyle{fancy}
  \fancyhf{}
  \fancyhead[RO, LE]{\thepage}
  \fancyhead[RE]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
}



```{python}
from scipy import stats
import pandas  as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
```


```{python}
df_mulher = pd.read_csv(
	"data/mulher_idade_2000_2010.csv",
  	delimiter="\t"
  	)\
  	.rename(
  	  	columns={
  	    	"2000": "Mulheres_2000",
			"2010": "Mulheres_2010"
		}
  	)

df_tfe = pd.read_csv(
	"data/tfe_roraima_2000_2010.csv",
	delimiter="\t"
	)\
  	.set_index("Ano")\
  	.stack()\
  	.reset_index(name="TFE")\
  	.set_index(["Ano", "level_1"])\
  	.unstack(0)\
  	.reset_index()\
  	.droplevel(0, axis=1)\
  	.rename(
		columns={
			"": "Idade",
			2000: "TFE_2000",
			2010: "TFE_2010"
  	    }
  	)

df_mulher_tfe = df_mulher\
  	.merge(df_tfe, on="Idade")\
  	.assign(
  	  	estimado_2000=lambda x: (x.Mulheres_2000 * x.TFE_2000).sum(),
  	  	estimado_2010=lambda x: (x.Mulheres_2010 * x.TFE_2010).sum(),
  	  	cobertura_2000=lambda x: 9744 / x.estimado_2000,
  	  	cobertura_2010=lambda x: 9738 / x.estimado_2010
  	)

df_tfe.columns.name = None


df_nasc = pd.DataFrame(
    {
        "Ano": [2010, 2020],
        "Masculino": [4990, 7075],
        "Feminino": [4748, 6684]
    }
)

df_obito = pd.DataFrame(
    {
        "Ano": [2020, 2010],
        "Óbito": [3580, 1640]
    }
)

df_pop = pd.DataFrame(
    {
        "Ano": [2020, 2010],
        "População": [563_000, 450479]
    }
)

df_obito_pop = df_obito\
  	.merge(
		df_pop,
  	  	on="Ano",
  	  	how="left"
  	)\
  	.merge(
  	  	df_nasc\
			.assign(nasc_total=lambda x: x.Masculino + x.Feminino)\
  	  	  	.drop(columns=["Masculino", "Feminino"]),
  	  	on="Ano"
  	)
```


# Introdução


# Metodologia

## Métodos para estimação da cobertura de nascidos vivos

\ \ \ A estimação do número de nascidos vivos é essencial para a análise demográfica e epidemiológica, especialmente em contextos onde há subnotificação ou inconsistências nos registros civis. Diversos métodos podem ser utilizados para avaliar a cobertura dos nascimentos, como comparações entre fontes de dados, modelagem estatística e ajustes baseados em fatores demográficos. Nesta seção, serão apresentadas as principais técnicas utilizadas para essa estimação.

### Razão de sexo dos nascimentos (RSN)

\ \ \ A Razão de Sexo dos Nascimentos (RSN) é um indicador que expressa a relação entre o número de nascidos vivos do sexo masculino e feminino em uma população. Geralmente, espera-se que essa razão esteja em torno de 105, indicando um leve predomínio de nascimentos masculinos sobre os femininos.

\vspace{12pt}

O cálculo da RSN é feito pela seguinte fórmula:

$$
RSN = \frac{N_M}{N_F} \times 100 \text{,}
$$
em que $N_M$ representa o número de nascidos vivos do sexo masculino e $N_F$ do sexo feminino.

\vspace{12pt}

Valores significativamente diferentes do esperado podem indicar problemas na qualidade dos dados, como erros de registro ou subnotificação diferenciada por sexo.

\vspace{12pt}

Os limites do intervalo de confiança a $95\%$ podem ser calculados a partir da seguinte expressão:

$$
\left[x, y\right] = p_{M} \pm 1,96 \sqrt{\frac{p_{M}p_{F}}{n}} \text{,}
$$
em que $n$ é o número total de nascimentos, $p_{M}$ é a proporção de nascidos vivos do sexo masculino e $p_{F}$ do sexo feminino.

\vspace{12pt}

Por fim, para verificar se a qualidade de registro de nascimentos é boa, basta verificar se o resultado das relações de sexo está incluso no intervalo $\left[a, b\right]$:

$$
a = \frac{x}{1 - x} \times 100 \text{ e } b = \frac{y}{1-y}\times 100\text{.}
$$

### Método que utiliza a equação básica do crescimento populacional

O método que utiliza a equação básica do crescimento populacional é bastante simples, principalmente por assumir que a popuação é fechada. Dessa forma, a estimativa de nascidos vivos será expresso pela equação:

$$
N_t = P_n - P_{0} + O_t
$$
em que $P_n$ são os nascidos vivos no instante $n$, P_{0} no instante inicial  e $O_t$ os óbitos no período de estudo.

\vspace{12pt}

A partir dessa expressão, estima-se a cobertura dos nascimentos da seguinte forma:

$$
\text{Cobertura dos nascimentos} = \frac{\text{Nascimentos registrados}\left(t\right)}{\text{Nascimentos esperados}\left(t\right)} \times 100
$$

### Método que faz uso das taxas de fecundidade

Neste método serão utilizadas as taxas de fecundidade do estado de Roraima. Para estimar a cobertura nesse método, será utilizada a seguinte expressão:

$$
C_i = \frac{NV_{obs}\left(i\right)}{NV_{est}\left(i\right)} \text{,}
$$
em que $NV_{obs}\left(i\right)$ é o total de nascidos vivos observados na região $i$ e $NV_{est}\left(i\right)$ é o total de nascidos vivos estimados na região $i$.

\vspace{12pt}

Para encontrar a estimativa dos nascidos vivos $NV_{est}\left(i\right)$, será utilizado a taxa de fecundidade do estado de Roraima, que pode ser encontrado a partir da seguinte expressão:

$$
NV_{est} = \sum^{49}_{j=15} TEF_{j}\left(i\right) \times TM_{j} \text{,}
$$
em que $TEF_{j}\left(i\right)$ é a taxa específica de fecundidade na faixa etária quinquenal $j$ da região $i$ e $TM_j$ é o total de mulheres na faixa etária quinquenal $j$ da região $j$.

### Método que faz uso da informação do SINASC e do IBGE

Aqui são utilizadas as estimativas de nascidos vivos fornecidos pelo IBGE e os nascidos vivos fornecidos pelo SINASC. Por fim, para estimar a cobertura, basta calcular utilizar a seguinte expressão:

$$
C_i = \frac{NV_{obs}\left(i\right)}{NV_{est}\left(i\right)}
$$

## Métodos para estimação da cobertura de óbito

A cobertura dos óbitos refere-se à proporção de mortes registradas em relação ao total de óbitos ocorridos em uma população. Em contextos onde há subnotificação ou falhas nos sistemas de informação, diferentes métodos são empregados para estimar a verdadeira magnitude da mortalidade.

\vspace{12pt}

Entre as principais abordagens utilizadas, destacam-se os métodos demográficos indiretos, como o método de Brass, que utiliza informações da estrutura etária da população e da mortalidade infantil para estimar a cobertura. Além disso, comparações entre diferentes bases de dados, modelagem estatística e técnicas de reconciliação de fontes são amplamente empregadas para corrigir deficiências nos registros.

\vspace{12pt}

Esses métodos são fundamentais para garantir a confiabilidade dos indicadores de mortalidade e subsidiar políticas públicas voltadas à saúde e ao planejamento populacional.

### Método que faz uso da equação básica do crescimento populacional

De forma semelhante ao método de cobertura de nascidos vivos que faz uso da equação básica do crescimento populacional, para estimar os óbitos, basta isolar a sua componente:

$$
O_t = N_t + P_{0} - P_n
$$

Por fim, para estimar a cobertura de óbitos, utiliza-se a seguinte expressão:

$$
\text{Cobertura dos óbitos} = \frac{\text{Óbitos registrados}\left(t\right)}{\text{Óbitos esperados}\left(t\right)} \times 100
$$

### Método da Equação do Balanço de Crescimento de Brass

Esse método avalia a cobertura de óbitos da população a partir dos cinco anos de idade. Para fazer sua aplicação, é necessário considerar a população estável, a cobertura de óbitos é constante por idade a partir dos 5 anos e as distribuições por idade da população não devem conter erros de declaração.

\vspace{12pt}

Nesse método é utilizado uma regressão linear, a partir da qual será estimada o fator de correção dos óbitos $\left(k\right)$, a taxa de crescimento da população estável $\left(r\right)$. Dessa forma, essa regressão linear terá a seguinte relação:

$$
\frac{N\left(a\right)}{N\left(a+\right)} = r + k\frac{D^{'}\left(a+\right)}{N\left(a+\right)}\text{,}
$$
em que $N\left(a\right)$ é a população exata na idade $a$, $N\left(a+\right)$ o somatório de pessoas que estão na idade exata até um limite de idades $w$ qualquer e $D^{'}\left(a+\right)$ são os óbitos registrados e afetados por erros na idade $a+$.

\vspace{12pt}

Após o ajuste da regressão linear, a cobertura dos óbitos será dada por:

$$
C = \frac{1}{k}\text{,}
$$
em que se o fator de correção for $k > 1$ implica em sub-registro e $k<1$ implica em sobre-registro.

### Método de Leadermann para redistribuição

O método de Leadermann é uma abordagem utilizada para redistribuir óbitos classificados com causas mal definidas entre categorias específicas de mortalidade. Essa técnica busca minimizar o impacto da subnotificação e da imprecisão nos registros, permitindo uma estimativa mais fiel da estrutura de mortalidade de uma população.

\vspace{12pt}

A redistribuição é feita com base na suposição de que a proporção de óbitos por causas definidas segue um padrão semelhante ao dos óbitos mal definidosa. Assim, os óbitos mal classificados são redistribuídos proporcionalmente entre as categorias bem definidas, considerando a estrutura observada nos registros mais completos. Isso é feito utilizando-se uma regressão linear

\vspace{12pt}

A equação de redistribuição dos óbitos por causas mal definidas para uma determinada área é dada por:

$$
O_j = Y_j - X \beta_{j}
$$
em que $O_j$ são os óbitos redistribuídos da causa $j$, $Y_j$ os óbitos observados da causa $j$, $\beta_j$ é o fator de redistribuição da causa $j$ e $X$ são os óbitos da causa mal definida.

# Resultado

## Resultado da estimação de cobertura de nascimentos

Nesta seção serão apresentadas cada uma das técnicas utilizadas para analisar e estimar a cobertura dos nascidos vivos. O primeiro deles será o RSN, depois o método de estimação utilizando a equação do crescimento populacional, o que o utiliza as taxas de fecundidade e por último o que utiliza as estimativas do IBGE e os dados do SINASC.

### Razão de Sexo dos Nascimentos (RSN)

A abaixo apresenta os valores da Razão de Sexo dos Nascimentos (RSN) para os anos de 2010 e 2020. Esse indicador expressa a relação entre os nascidos vivos do sexo masculino e feminino, sendo esperado um valor em torno de 105 em condições normais.

```{python}
#| tbl-cap: Resultados da Razão de sexo dos nascimentos para o ano de 2010 e 2020

df_nasc\
	.assign(
		RSN=lambda x: (x.Masculino / x.Feminino * 100).round(4),
  	  	total=lambda x: x.Masculino + x.Feminino,
  	  	x=lambda x: x.Masculino / x.total - np.sqrt((x.Masculino / x.total * x.Feminino / x.total) / x.total).round(4),
  	  	y=lambda x: x.Masculino / x.total + np.sqrt((x.Masculino / x.total * x.Feminino / x.total) / x.total).round(4),
  	  	a=lambda x: (x.x / (1 - x.x) * 100).round(4),
  	  	b=lambda x: (x.y / (1 - x.y) * 100).round(4),
  	).style\
	.set_table_styles([
        {"selector": "th", "props": [("text-align", "center")]},
        {"selector": "td", "props": [("text-align", "center")]}
    ])\
	.format("{:.3f}", subset=["RSN", "x", "y", "a", "b"]).hide()
```

Em 2010, a RSN foi de 105,097, indicando que para cada 100 meninas nasceram aproximadamente 105 meninos. Já em 2020, esse valor aumentou para 105,850, sugerindo um leve crescimento na proporção de nascimentos masculinos em relação aos femininos. Além disso, ao observar o intervalo $\left[a, b\right]$, tem-se que há uma boa qualidade no registro dos dados, pois os valores estimados da $RSN$ estão contidos dentro do intervalo.


### Método que utiliza a equação básica do crescimento populacional

```{python}
df_obito_pop\
	.assign(
		nascimento_esperado=lambda x: x["População"].iloc[0] - x["População"].iloc[1] + x["Óbito"].iloc[0] + x["Óbito"].iloc[1],
    	cobertura_estimada=lambda x: (x.nasc_total.iloc[0] + x.nasc_total.iloc[1]) / x.nascimento_esperado * 100
  	).style\
	.set_table_styles([
        {"selector": "th", "props": [("text-align", "center")]},
        {"selector": "td", "props": [("text-align", "center")]}
	])\
	.format("{:.3f}", subset=["nascimento_esperado", "cobertura_estimada"]).hide()
```

\blandscape

### Método que faz uso das taxas de fecundidade


```{python}
df_mulher_tfe\
	.rename(
		columns={
			"estimado_2000": "NV_2000",
			"estimado_2010": "NV_2010",
			"cobertura_2000": "C_2000",
			"cobertura_2010": "C_2010",
		}
	).style\
	.set_table_styles([
        {"selector": "th", "props": [("text-align", "center")]},
        {"selector": "td", "props": [("text-align", "center")]}
	])\
	.format("{:.3f}", subset=["TFE_2000", "TFE_2010", "NV_2000", "NV_2010", "C_2000", "C_2010"]).hide()
```

\elandscape

### Método que faz uso dos dados do IBGE e SINASC

```{python}
pd.DataFrame(
	{
		"Ano": [2020, 2010],
    	"IBGE": [13991, 10686],
    	"SINASC": [13760, 9738],
  	}
).assign(Cobertura=lambda x: x.SINASC / x.IBGE)
```

## Resultados da estimação de cobertura de óbitos


### Método que utiliza a equação básica do cresimento populacional

```{python}
df_cobert_obito = pd.DataFrame(
	{
		"Ano": [2010, 2000],
		"População": [450_479, 324_397],
		"Nascidos": [9738, 9744],
	}
).assign(obito_estimado=lambda x: (x.Nascidos.loc[0] + x.Nascidos.loc[1]) - x.População.loc[0] + x.População.loc[1])
```

### Método da equação do balanço de crescimento de Brass


```{python}
df_brass = pd.read_csv("data/brass_2010.csv")\
	.assign(
		N_a_homens=lambda x: np.cumsum(list(reversed(x.Homens)))[::-1],
		N_a_mulheres=lambda x: np.cumsum(list(reversed(x.Mulheres)))[::-1],
	)
df_brass_2022 = pd.read_csv("data/brass_2022.csv")\
	.assign(
		N_a_homens=lambda x: np.cumsum(list(reversed(x.Homens)))[::-1],
		N_a_mulheres=lambda x: np.cumsum(list(reversed(x.Mulheres)))[::-1],
	)
df_brass = pd.concat([df_brass, df_brass_2022])

df_brass_obt = pd.read_csv("data/obitos_2010.csv").assign(
	Ano=2010,
	D_a_homens=lambda x: np.cumsum(list(reversed(x.Homens)))[::-1],
	D_a_mulheres=lambda x: np.cumsum(list(reversed(x.Mulheres)))[::-1],
	)
df_brass_obt_2022 = pd.read_csv("data/obitos_2022.csv")\
	.assign(
		Ano=2022,
		D_a_homens=lambda x: np.cumsum(list(reversed(x.Homens)))[::-1],
		D_a_mulheres=lambda x: np.cumsum(list(reversed(x.Mulheres)))[::-1],
	)
df_brass_obt = pd.concat([df_brass_obt, df_brass_obt_2022])\
	.rename(columns={"Homens": "Homens_obitos", "Mulheres": "Mulheres_obitos"})

df_brass = df_brass\
	.merge(df_brass_obt, on=["Faixa etária", "Ano"])\
	.assign(
		y_homens=lambda x: x.Homens_a / x.N_a_homens,
		y_mulheres=lambda x: x.Mulheres_a / x.N_a_mulheres,
		x_homens=lambda x: x.D_a_homens / x.N_a_homens,
		x_mulheres=lambda x: x.D_a_mulheres / x.N_a_mulheres,
	)
```


```{python}
def fit_regression(df, year, gender):
    df_filtered = df[df["Ano"] == year].dropna(subset=[f"x_{gender}", f"y_{gender}"])
    x = df_filtered[f"x_{gender}"].values
    y = df_filtered[f"y_{gender}"].values

    slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
    return slope, intercept, r_value**2

for year in [2010, 2022]:
    for gender in ["homens", "mulheres"]:
        try:
            slope, intercept, r2 = fit_regression(df_brass, year, gender)
            print(f"Year: {year}, Gender: {gender}, Slope: {slope:.4f}, Intercept: {intercept:.4f}, R²: {r2:.4f}")
        except Exception as e:
            print(f"Error for {year} - {gender}: {e}")

```

### Método de Leadermann


```{python}
df_leadermann_homens = pd.read_csv("data/leadermann_homens.csv", delimiter=";")\
	.rename(columns={"Capítulo CID-10": "Causas"})\
	.astype(
		{
			"14001 BOA VISTA": float,
			"14002 NORDESTE DE RORAIMA": float,
			"14003 CARACARAI": float,
			"14004 SUDESTE DE RORAIMA": float
		}
	)
```


```{python}
X_values = df_leadermann_homens.query("Causas == 'Mal definidas'").values.flatten()[1:].astype(float)
regions = df_leadermann_homens.columns[1:].tolist()

results = []

for cause in df_leadermann_homens.query("Causas != 'Mal definidas'").Causas.unique().tolist():
    Y = df_leadermann_homens.query("Causas == @cause").values.flatten()[1:].astype(float)

    slope, intercept, r_value, p_value, std_err = stats.linregress(X_values, Y)
    predicted_Y = slope * X_values + intercept

    results.append(pd.DataFrame({
        'Causas': [cause] * len(regions),
        'Region': regions,
        'Observed': Y,
        'Predicted': predicted_Y,
        'Slope': [slope] * len(regions),
        'Intercept': [intercept] * len(regions)
    }))

df_results = pd.concat(results, ignore_index=True)
```



```{python}
df_leadermann_mulheres = pd.read_csv("data/leadermann_mulheres.csv", delimiter=";")\
	.replace("-", "0")\
	.astype(
		{
			"14001 BOA VISTA": float,
			"14002 NORDESTE DE RORAIMA": float,
			"14003 CARACARAI": float,
			"14004 SUDESTE DE RORAIMA": float
		}
	)
```


```{python}
X_values = df_leadermann_mulheres.query("Causas == 'Mal definidas'").values.flatten()[1:].astype(float)
regions = df_leadermann_mulheres.columns[1:].tolist()

results = []

for cause in df_leadermann_mulheres.query("Causas != 'Mal definidas'").Causas.unique().tolist():
    Y = df_leadermann_mulheres.query("Causas == @cause").values.flatten()[1:].astype(float)

    slope, intercept, r_value, p_value, std_err = stats.linregress(X_values, Y)
    predicted_Y = slope * X_values + intercept

    results.append(pd.DataFrame({
        'Causas': [cause] * len(regions),
        'Region': regions,
        'Observed': Y,
        'Predicted': predicted_Y,
        'Slope': [slope] * len(regions),
        'Intercept': [intercept] * len(regions)
    }))

df_results_mulheres = pd.concat(results, ignore_index=True)
```
