---
format: pdf
title: Relatório (escolher o nome depois)
number-sections: false
indent: true
whitespace: small
documentclass: scrreprt
lang: pt-br
bibliography: includes/bib.bib
csl: includes/ufpe-abnt.csl
subtitle: Universidade Federal da Paraíba - CCEN
author: Gabriel de Jesus Pereira
date: today
date-format: long
highlight-style: github
fontsize: 12pt
interlinespace: 1.5pt
fig-cap-location: bottom
warning: false
echo: false
include-in-header:
  - text: |
      \usepackage{pdflscape}
      \newcommand{\blandscape}{\begin{landscape}}
      \newcommand{\elandscape}{\end{landscape}}
---

## Questão 1: Considere as seguintes funções $S\left(t\right)$ apresentadas abaixo e responda o que se pede.

1. $S_1\left(t\right) = e^{-t/5}$, em que $t \geq 0$

2. $S_2\left(t\right) = \frac{1}{1 + t}$, em que $t \geq 0$.

3. $S_3\left(t\right) = 1 - \frac{t}{2}$, em que $t \geq 0$

3. $S_4\left(t\right) = 2e^{-t/2}$, em que $t \geq 0$

(a) Considerando as condições, vistas em sala de aula, para que $S\left(t\right)$ seja uma função de sobrevivência, identifique quais das funções apresentadas são realmente funções de sobrevivência.

**Resolução (a)**

Para que $S\left(t\right)$ seja uma função de sobrevivência, deve satisfazer as seguintes condições: $S\left(t\right) \rightarrow 0$ para $t \rightarrow \infty$ e $S\left(t\right) \rightarrow 1$ para $t \rightarrow 0$. Assim, temos os seguintes resultados:

1. $\lim_{t \rightarrow \infty} e^{-t/5} = 0$ e $\lim_{t \rightarrow 0} e^{-t/5} = 1$

2. $\lim_{t \rightarrow \infty} \frac{1}{1+t} = 0$ e $\lim_{t \rightarrow 0} \frac{1}{1 + t} = 1$

3. $\lim_{t \rightarrow \infty} \left(1 - \frac{t}{2}\right) = -\infty$ e $\lim_{t \rightarrow 0} \left(1 - \frac{t}{2}\right) = 1$

4. $\lim_{t \rightarrow \infty} 2e^{-t/2} = 0$ e $\lim_{t \rightarrow 0} 2e^{-t/2} = 2$

Dessa forma, pelas condições necessárias, vemos que apenas $S_{1}\left(t\right)$ e $S_{2}\left(t\right)$ validam a condição para ser uma função de sobrevivência.

```{r}
library(flexsurv)
library(discSurv)
library(survival)
library(tidyverse)
library(vroom)
library(mice)
```


```{r}
round_interval <- function(interval) {
  bound_lev <- str_extract_all(levels(interval), "\\d+\\.*\\d*") |>
    lapply(\(x) as.numeric(x) |> ceiling())
  boundaries <- str_extract_all(interval, "\\d+\\.*\\d*") |>
    lapply(\(x) as.numeric(x) |> ceiling())
  lower_lev <- lapply(bound_lev, \(x) x[1])
  upper_lev <- lapply(bound_lev, \(x) x[2])
  lower <- lapply(boundaries, \(x) x[1])
  upper <- lapply(boundaries, \(x) x[2])

  fac_interval <- paste0("[", lower_lev, ",", upper_lev, ")")
  new_interval <- paste0("[", lower, ",", upper, ")")
  factor(new_interval, levels = fac_interval)
}

df <- read_delim("includes/dialcompete.txt", delim = " ") |>
  mutate(
    intervalo = cut(
      tempo,
      breaks = 43,
      right = FALSE
    ),
    intervalo = round_interval(intervalo)
  )
```

```{r eval=FALSE}

df <- read_delim("sobrevivencia/primeira_avaliacao/includes/dialcompete.txt", delim = " ") |>
  mutate(
    intervalo = cut(
      tempo,
      breaks = 43,
      right = FALSE
    ),
    intervalo = round_interval(intervalo)
  )
```


## Questão 2:

Escolha um dos bancos de dados disponíveis no seguinte endereço eletrônico: **http://sobrevida.fiocruz.br/dados.html**. A partir do banco de dados escolhido por você, faça o que se pede a seguir

### 2b)

Considerando a variável de tempo até ocorrência do evento de interesse na base de dados escolhida, forneça as seguintes informações:

\vspace{12pt}

**i)** É possível montar uma tabela para descrever os dados de acordo com o número de ocorrências do evento de interesse registradas em intervalos de tempo da pesquisa? Se sim, apresente-a.

```{r}
tabela_eventos <- df |>
  group_by(intervalo) |>
  mutate(
    falhas = sum(status, na.rm = TRUE),
    censura = sum(status == 0, na.rm = TRUE),
    amplitude = (\(x) {
      inter = as.character(intervalo) |>
        gsub(pattern = "\\[|\\(|\\)", replacement = "") |>
        strsplit(",")

      sapply(
        X = inter,
        FUN = \(x) {
          as.numeric(x[2]) - as.numeric(x[1])
        })
    })(),
  ) |>
  ungroup() |>
  arrange(intervalo) |>
  filter(status != 0) |>
  select(-c(
    status, id, idade,
    doenca, motivo)
  ) |>
  distinct(intervalo, .keep_all = TRUE)

nj <- nrow(df)
for (x in 2:nrow(tabela_eventos)) {
  nj[x] <-  nj[x - 1] - (tabela_eventos$falhas[x - 1] + tabela_eventos$censura[x - 1])
}

tabela_eventos |>
  mutate(risco = nj) |>
  knitr::kable()
```


**ii**. Apresente o cálculo de sobrevivência empírica (pela definição apresentada na aula 1). Apresente também as estimativas empíricas das seguintes quantidades: função densidade, função de risco, função de risco acumulada.


```{r}

# empirica

tabela_empirica <- tabela_eventos |>
  mutate(
    risco = nj,
    `S(t)` = nj / nrow(df),
    `f(t)` = falhas / (amplitude * nrow(df)),
     `h(t)` = falhas / (risco * amplitude),
     `H(t)` = - log(`S(t)`),
     across(`S(t)`:`H(t)`, ~ round(.x, 4))
  )

tabela_empirica |>
  select(-amplitude) |>
  knitr::kable()
```

\newpage

**iii**. Apresente o cálculo da função de sobrevivência $S\left(t\right)$ considerando os seguintes estimadores: Kaplan-Meier, Nelson-Aalen e Tabela de Vida. Para cada versão desses estimadores, apresente também as estimativas das seguintes quantidades: função densidade, função de risco, função de risco acumulada. Interprete os resultados.

```{r}
tabela_de_vida <- lifeTable(
  as.data.frame(df),
  timeColumn = "tempo",
  eventColumn = "status"
  )$Output |>
  as_tibble()

tabela_de_vida |>
  mutate(
    upper = S + qnorm(1 - 0.05) * seS,
    lower = S - qnorm(1 - 0.05) * seS,
    `f(t)` = hazard * S
  ) |>
  select(
    n, events, dropouts,
    hazard, S, lower, upper,
    cumHazard, `f(t)`
  ) |>
  knitr::kable()
```

```{r}
# kaplan meier
ekm <- survfit(
  Surv(df$tempo, df$status) ~ 1,
  conf.type = "plain"
)

tabela_ekm <- ekm |>
  summary() |>
  (\(x) {
    tibble(
      tempo = x$time,
      risco = x$n.risk,
      falha = x$n.event,
      censura = x$n.censor,
      `S(t)` = x$surv,
      upper = x$upper,
      lower = x$lower,
      `H(t)` = x$cumhaz,
      amplitude = tabela_eventos$amplitude
    ) |>
    mutate(
      `h(t)` = (1 - (risco - falha) / risco) / amplitude,
      `f(t)` = `h(t)` * `S(t)`
    )
  })()

tabela_ekm |>
  select(-amplitude) |>
  knitr::kable()
```

```{r}
# nelson alen

alen <- survfit(
  Surv(df$tempo, df$status) ~ 1, type = "fleming-harrington"
)

tabela_alen <- alen |>
  summary() |>
  (\(x) {
    # tab <- sapply()

    tab <- tibble(
      tempo = x$time,
      risco = x$n.risk,
      falha = x$n.event,
      censura = x$n.censor,
      `S(t)` = x$surv,
      lower = x$lower,
      upper = x$upper,
      `H(t)` = x$cumhaz,
      amplitude = tabela_eventos$amplitude
    )

    tab |>
      mutate(
        `h(t)` =  sapply(X = 1:nrow(tab), FUN = \(x) {
          surv_ant = tab$`S(t)`[x]
          surv_pos = tab$`S(t)`[x + 1]
          time_pos = tab$tempo[x + 1]
          time_ant = tab$tempo[x]

          if (x == nrow(tab)) {
            1
            } else {
              (surv_ant - surv_pos) / ((time_pos - time_ant) * surv_ant)
              }
            }),
        `f(t)` = `h(t)` * `S(t)`
      )
  })()
```

**iv**. Explique como o teste de LogRank deve ser aplicado. Escolha uma variável qualitativa de sua base e realize o teste de comparação de curvas de sobrevivência. Interprete adequadamente os resultados.

```{r}
grupos <- list("outr", "hiper", "diab", "rim", "cong")
results <- list()
results_tibble <- tibble::tibble(
  comparação = character(),
  estatística = numeric(),
  `p-valor` = numeric()
)

for (i in 1:(length(grupos) - 1)) {
  for (j in (i + 1):length(grupos)) {
    grupo1 <- grupos[[i]]
    grupo2 <- grupos[[j]]
    data_subset <- df[df$doenca %in% c(grupo1, grupo2),]

    test_result <- survdiff(
      Surv(data_subset$tempo, data_subset$status) ~ data_subset$doenca,
      rho = 0
    )
    statistic <- test_result$chisq
    pvalue <- test_result$pvalue
    result_name <- paste(grupo1, grupo2, sep = " vs ")

    results_tibble <- results_tibble |>
      add_row(
        comparação = result_name,
        estatística = statistic,
        `p-valor` = pvalue
      )
  }
}
results_tibble |>
  knitr::kable()
```


```{r}
expo_fit <- flexsurvreg(
  Surv(df$tempo, df$status) ~ 1,
  dist = "exponential")

weib_fit <- flexsurvreg(
  Surv(df$tempo, df$status) ~ 1,
  dist = "weibull")

gengamma_fit <- flexsurvreg(
  Surv(df$tempo, df$status) ~ 1,
  dist = "gengamma")

lognormal_fit <- flexsurvreg(
  Surv(df$tempo, df$status) ~ 1,
  dist = "lognormal")

gamma_fit <- flexsurvreg(
  Surv(df$tempo, df$status) ~ 1,
  dist = "gamma")

dists <- list(
  expo_fit, weib_fit,
  gengamma_fit, lognormal_fit,
  gamma_fit)

alltho <- lapply(dists, \(x) {
  name <- x$call$dist
  x |>
  summary() |>
  (\(y) {
    y <- y[[1]]
    tibble(
      tempo = y$time,
      `S(t)` = y$est,
      lower = y$lcl,
      upper = y$ucl,
      estimador = name
    )
    })()
  }) |>
  Reduce(f = rbind)
```

```{r}
tibble(
  Modelo = c(
    "Gama Generalizado", "Exponencial",
    "Weibull", "Log-Normal", "Gama"
    ),
  logvero = c(
    logLik(gengamma_fit), logLik(expo_fit),
    logLik(weib_fit), logLik(lognormal_fit),
    logLik(gamma_fit)
    ),
  AIC = c(
    AIC(gengamma_fit), AIC(expo_fit),
    AIC(weib_fit), AIC(lognormal_fit),
    AIC(gamma_fit)
    ),
  BIC = c(
    BIC(gengamma_fit), BIC(expo_fit),
    BIC(weib_fit), BIC(lognormal_fit),
    BIC(gamma_fit)
    )
  ) |>
  mutate(
    TRV = c(NA, 2 * (logvero[2:5] - logvero[1])),
    `p-valor` = c(NA, 1 - pchisq(TRV[2:5], df = c(2, 1, 1, 1)))
  ) |>
  knitr::kable()
```


```{r}
st1 <- \(t) exp(-t/5)
st2 <- \(t) 1 / (1 + t)
```


```{r}
alltho |>
  pivot_wider(
    names_from = estimador,
    values_from = `S(t)`:upper
  )

alltho |>
  ggplot(aes(x = tempo, y = `S(t)`)) +
  geom_line() +
  geom_ribbon(
    data = alltho,
    aes(ymin = lower, ymax = upper),
    alpha = 0.3
  ) +
  facet_wrap(vars(estimador), scales = "free") +
  theme_bw()
```
